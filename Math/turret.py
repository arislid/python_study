from sympy import Symbol, solve
import sympy as sp
'''
너무 어렵게 생각하지 말자. 생각보다 답은 심플할 수도 있다.

reference: https://www.acmicpc.net/board/view/38854
가능한 경우는 다음 6가지입니다.
    1. 두 원이 일치할 때, 답은 -1 
    2. 두 원이 외접할 때, 답은 1
    3. 두 원이 내접할 때, 답은 1
    4. 두 원이 서로 떨어져 있고 만나지 않을 때, 답은 0
    5. 한 원이 다른 원의 내부에 있고 두 원이 만나지 않을 때, 답은 0. 꼭 두 원의 중심이 같을 필요는 없습니다!
    6. 나머지 경우, 답은 2
6가지 경우를 모두 넣으셨으면, 반드시 각각의 경우가 모두 잘 나오는지 직접 테스트를 해 봅시다.

두 중심 사이 거리를 R이라고 할 때, 무턱대고 R == r1 + r2인지 검사하는 것은 매우 위험합니다. 
조금의 오차라도 생기면 두 실수는 같지 않게 되기 때문입니다. 간단한 예시로, 0.1 + 0.2 == 0.3은 참이 아닙니다. 
마찬가지로 r1, r2 등을 float, double 등의 자료형으로 저장하면 위험합니다.

R을 int 단위로 버림한 다음에 R == r1 + r2인지 검사해도 안 됩니다. 버림하는 순간 더 이상 거리가 아닙니다.
R2 == r12 + r22인지 검사해도 안 됩니다. 그 식이랑 R == r1 + r2는 매우 다른 식입니다.
R을 계산한 다음에 거기에 R을 곱해서 R2을 만들어도 안 됩니다. 
R을 계산한 순간 이미 오차가 생겼기 때문에 R2에도 오차가 생깁니다. 
다행히도 R2을 오차 없이 계산하는 방법이 존재합니다. 힌트는 여기까지 드리겠습니다.
'''

def where_are_they():
    x1, y1 = 0, 0
    x2, y2 = 0, 0
    
    
r1, r2 = sp.symbols('r1 r2')

expr1 = (r1 - 3) ** 2 + (r2 - 6) ** 2 - 9
expr2 = (r1 - 0) ** 2 + (r2 - 15) ** 2 - 12

ans = solve((expr1, expr2), r1, r2,dict=True) 
print(f"ans = {ans}")
print(type(ans))
print(type(r1))